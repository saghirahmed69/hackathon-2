# Implementation Plan: Advanced Task Management Features

**Branch**: `003-advanced-task-features` | **Date**: 2025-12-26 | **Spec**: [spec.md](spec.md)

**Input**: Feature specification from `/specs/003-advanced-task-features/spec.md`

## Summary

Extend the existing Phase II todo application with 7 advanced task management features while maintaining full backward compatibility. The implementation adds: (1) mandatory task priority levels, (2) optional due dates with overdue detection, (3) real-time keyword search, (4) multi-criteria filtering, (5) flexible sorting, (6) recurring task automation, and (7) browser-based reminder notifications. All features integrate seamlessly with the existing Next.js 16+ frontend, FastAPI backend, SQLModel ORM, and Neon PostgreSQL database.

## Technical Context

**Language/Version**:
- Frontend: TypeScript with Next.js 16+ (App Router), Node.js 18+
- Backend: Python 3.10+

**Primary Dependencies**:
- Frontend: Next.js 16+, React 18+, Better Auth, Tailwind CSS, TypeScript, Browser Notifications API
- Backend: FastAPI, SQLModel, Pydantic, python-jose[cryptography] (JWT), passlib, asyncpg, python-dateutil

**Storage**: Neon Serverless PostgreSQL (existing, extended with 5 new columns)

**Testing**: Manual testing per quickstart.md (automated tests optional)

**Target Platform**:
- Frontend: Modern web browsers with Notifications API support (Chrome, Firefox, Safari, Edge)
- Backend: Linux/macOS server environment

**Project Type**: Web application (monorepo: frontend/ + backend/)

**Performance Goals**:
- Real-time search: <300ms debounce delay, <2s results
- Filter/sort operations: <2s response time
- Recurring task generation: <3s after completion
- Notification delivery: <5s from scheduled time
- Backward compatibility: 0% regression in existing features

**Constraints**:
- No manual code writing (all code generated by Claude Code)
- Backward compatible API (existing endpoints continue working unchanged)
- Database migration must succeed without data loss
- User isolation maintained for all new features
- Browser notification permissions handled gracefully

**Scale/Scope**:
- 5 new database columns (priority, due_date, is_recurring, recurrence_pattern, reminder_time)
- 6 new query parameters (search, status, priority, due_date, sort_by, sort_order)
- Extended service layer with filtering, sorting, and recurrence logic
- 8+ new frontend UI components/controls
- 78 functional requirements (FR-001 to FR-078)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Phase II Extension Constitution Compliance

| Principle | Requirement | Status | Notes |
|-----------|-------------|--------|-------|
| **I. Spec-Driven First** | All development from written specs | ‚úÖ PASS | spec.md complete with 78 FRs, 7 user stories, clarifications |
| **II. No Manual Coding** | All code generated by Claude Code | ‚úÖ PASS | Workflow enforces AI generation |
| **III. Phase II Scope Discipline** | Full-stack web with auth, persistence, REST | ‚úÖ PASS | Extends Phase II without AI (Phase III scope) |
| **IV. Feature Completeness** | All 5 basic features remain intact | ‚úÖ PASS | Backward compatible, existing features unchanged |
| **V. Deterministic Behavior** | Clear UI, proper HTTP codes, error handling | ‚úÖ PASS | FR-056, FR-067-071 define contracts |
| **VI. Clean Architecture** | Frontend ‚Üî API ‚Üî DB separation | ‚úÖ PASS | Extends existing architecture patterns |
| **VII. Explicit Contracts** | UI and REST API documented | ‚úÖ PASS | Will generate in Phase 1: contracts/ |
| **VIII. Testability by Design** | Logic deterministic, endpoints testable | ‚úÖ PASS | Manual testing via quickstart.md |
| **IX. Spec Evolution Expected** | Iterative refinement allowed | ‚úÖ PASS | Spec is authoritative source |
| **X. Authentication First** | Better Auth + JWT required | ‚úÖ PASS | Reuses existing auth (FR-069) |
| **XI. Persistent Storage** | Neon PostgreSQL required | ‚úÖ PASS | FR-072 to FR-078 extend schema |
| **XII. User Isolation** | Database + API enforcement | ‚úÖ PASS | FR-070 maintains user isolation |
| **XIII. Full-Stack Separation** | Clear frontend/backend boundaries | ‚úÖ PASS | Extends REST API, no direct DB access |

**Gate Status**: ‚úÖ **ALL CHECKS PASSED** - Proceed to Phase 0 Research

**Violations**: None

## Project Structure

### Documentation (this feature)

```text
specs/003-advanced-task-features/
‚îú‚îÄ‚îÄ plan.md              # This file
‚îú‚îÄ‚îÄ research.md          # Phase 0 output (technology decisions)
‚îú‚îÄ‚îÄ data-model.md        # Phase 1 output (extended schema)
‚îú‚îÄ‚îÄ quickstart.md        # Phase 1 output (testing guide)
‚îú‚îÄ‚îÄ contracts/           # Phase 1 output (API extensions)
‚îÇ   ‚îú‚îÄ‚îÄ api-query-parameters.md
‚îÇ   ‚îú‚îÄ‚îÄ recurring-tasks-logic.md
‚îÇ   ‚îî‚îÄ‚îÄ browser-notifications.md
‚îî‚îÄ‚îÄ tasks.md             # Phase 2 output (/sp.tasks command)
```

### Source Code (repository root - extensions only)

```text
backend/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task.py                    # EXTEND: Add 5 new fields
‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task.py                    # EXTEND: Add new fields to schemas
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_service.py            # EXTEND: Add filtering, sorting, search logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ recurring_service.py       # NEW: Recurring task generation service
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tasks.py                   # EXTEND: Add query parameter handling
‚îÇ   ‚îî‚îÄ‚îÄ migrations/                     # NEW: Database migration scripts
‚îÇ       ‚îî‚îÄ‚îÄ add_advanced_features.py   # NEW: Migration for 5 new columns
‚îî‚îÄ‚îÄ requirements.txt                    # UPDATE: Add python-dateutil

frontend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tasks/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TaskForm.tsx           # EXTEND: Add new inputs
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TaskItem.tsx           # EXTEND: Add visual indicators
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TaskList.tsx           # EXTEND: Add search/filter/sort controls
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PrioritySelector.tsx   # NEW: Priority dropdown
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ DateTimePicker.tsx     # NEW: Due date/reminder picker
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ FilterControls.tsx     # NEW: Filter UI
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SortControls.tsx       # NEW: Sort UI
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ SearchBar.tsx          # NEW: Debounced search
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts                   # EXTEND: Add new Task fields
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts                     # EXTEND: Query parameter support
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ notifications.ts           # NEW: Browser notification service
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ useDebounce.ts             # NEW: Debouncing hook
‚îÇ       ‚îú‚îÄ‚îÄ useNotifications.ts        # NEW: Notification management
‚îÇ       ‚îî‚îÄ‚îÄ useTaskFilters.ts          # NEW: Filter/sort state
```

**Structure Decision**: Extends existing monorepo structure from Phase II. New files are additive; existing files are modified to add functionality while maintaining backward compatibility.

## Complexity Tracking

**No Violations**: All constitution checks passed. No complexity tracking needed.

---

## Implementation Layers

### Layer 1: Database Schema Extensions

#### 1.1 Schema Analysis

**Current Schema** (from Phase II):
```python
# Existing Task model fields:
id: UUID (Primary Key)
user_id: UUID (Foreign Key to users.id)
title: str (max 1000, NOT NULL)
description: Optional[str]
completed: bool (default False)
created_at: datetime
updated_at: Optional[datetime]
```

**Required Extensions** (FR-072 to FR-078):
```python
priority: str              # NOT NULL, ENUM('high', 'medium', 'low'), default 'medium'
due_date: Optional[datetime]      # NULLABLE timestamp
is_recurring: bool         # NOT NULL, default False
recurrence_pattern: Optional[str] # NULLABLE, ENUM('daily', 'weekly', 'monthly')
reminder_time: Optional[datetime] # NULLABLE timestamp
```

#### 1.2 Migration Strategy

**Approach**: Backward-compatible additive migration

**Migration Steps**:
1. Add 5 new columns with safe defaults:
   - `priority` VARCHAR(10) NOT NULL DEFAULT 'medium' CHECK (priority IN ('high', 'medium', 'low'))
   - `due_date` TIMESTAMP NULL
   - `is_recurring` BOOLEAN NOT NULL DEFAULT FALSE
   - `recurrence_pattern` VARCHAR(20) NULL CHECK (recurrence_pattern IN ('daily', 'weekly', 'monthly'))
   - `reminder_time` TIMESTAMP NULL

2. Backfill existing rows (FR-078):
   - Set `priority = 'medium'` for all existing tasks
   - Set `is_recurring = FALSE`
   - Leave nullable fields as NULL

3. Create indexes for performance:
   - `CREATE INDEX idx_tasks_priority ON tasks(user_id, priority)`
   - `CREATE INDEX idx_tasks_due_date ON tasks(user_id, due_date)`
   - `CREATE INDEX idx_tasks_reminder ON tasks(reminder_time)`

**Rollback Strategy**: Drop 5 columns and indexes

#### 1.3 SQLModel Changes

**File**: `backend/app/models/task.py`

**Extensions**:
```python
from enum import Enum
from typing import Literal

PriorityLevel = Literal['high', 'medium', 'low']
RecurrencePattern = Literal['daily', 'weekly', 'monthly']

class Task(SQLModel, table=True):
    # ... existing fields ...

    # NEW FIELDS (Phase II Extension)
    priority: PriorityLevel = Field(default='medium', max_length=10)
    due_date: Optional[datetime] = Field(default=None, nullable=True)
    is_recurring: bool = Field(default=False)
    recurrence_pattern: Optional[RecurrencePattern] = Field(default=None, max_length=20, nullable=True)
    reminder_time: Optional[datetime] = Field(default=None, nullable=True)
```

**Validation Rules**:
- Priority: Must be 'high', 'medium', or 'low' (enforced by Literal type + DB constraint)
- Due date: Accept ISO 8601, can be past or future (FR-008 to FR-017)
- Reminder time: Must be in future (validated in service layer per FR-056)

---

### Layer 2: Backend API Extensions

#### 2.1 Query Parameter Design

**File**: `backend/app/api/tasks.py`

**Extended GET Endpoint** (FR-066 to FR-071):
```python
@router.get("", response_model=List[TaskResponse])
async def get_tasks(
    current_user: User = Depends(get_current_user),
    session: AsyncSession = Depends(get_session),
    # NEW QUERY PARAMETERS
    search: Optional[str] = Query(None, max_length=500),
    status: Optional[Literal['pending', 'completed']] = Query(None),
    priority: Optional[Literal['high', 'medium', 'low']] = Query(None),
    due_date: Optional[str] = Query(None),
    sort_by: Optional[Literal['due_date', 'priority', 'title']] = Query(None),
    sort_order: Optional[Literal['asc', 'desc']] = Query('asc'),
) -> List[TaskResponse]:
    """Get all tasks with optional filtering, sorting, and search."""

    tasks = await task_service.get_user_tasks_filtered(
        session=session,
        user_id=current_user.id,
        search=search,
        status=status,
        priority=priority,
        due_date=due_date,
        sort_by=sort_by,
        sort_order=sort_order,
    )

    return [TaskResponse.from_orm(task) for task in tasks]
```

**Validation Logic** (FR-068):
- `search`: Sanitize special characters, truncate to 500 chars
- `due_date`: Parse operator prefix (before:/after:/on:), validate date format
- Invalid values: Return HTTP 400 with clear error message

#### 2.2 POST/PATCH Endpoint Extensions

**POST `/api/tasks`** (create task):
- Extend `TaskCreate` schema: priority (required), due_date, is_recurring, recurrence_pattern, reminder_time (optional)
- Validate priority in ['high', 'medium', 'low'] (FR-007)
- Validate reminder_time > current_time (FR-056)

**PATCH `/api/tasks/{task_id}`** (update task):
- Extend `TaskUpdate` schema with new optional fields
- Validate reminder_time > current_time when updating (FR-056)
- When toggling `completed=True` on recurring task: trigger recurrence logic (FR-046)

#### 2.3 Response Schema Extensions

**File**: `backend/app/schemas/task.py`

**Extended TaskResponse**:
```python
class TaskResponse(BaseModel):
    # ... existing fields ...

    # NEW FIELDS (Phase II Extension)
    priority: Literal['high', 'medium', 'low']
    due_date: Optional[str]  # ISO 8601 or null
    is_recurring: bool
    recurrence_pattern: Optional[Literal['daily', 'weekly', 'monthly']]
    reminder_time: Optional[str]  # ISO 8601 or null
```

---

### Layer 3: Backend Service Layer Logic

#### 3.1 Filtering and Search Service

**File**: `backend/app/services/task_service.py`

**New Function** (FR-018 to FR-042):
```python
async def get_user_tasks_filtered(
    session: AsyncSession,
    user_id: str,
    search: Optional[str] = None,
    status: Optional[str] = None,
    priority: Optional[str] = None,
    due_date: Optional[str] = None,
    sort_by: Optional[str] = None,
    sort_order: str = 'asc',
) -> List[Task]:
    """Get user tasks with filtering, sorting, and search."""

    # Start with base query (always filter by user)
    query = select(Task).where(Task.user_id == user_id)

    # Apply search (FR-018 to FR-025)
    if search and search.strip():
        search_term = f"%{search.strip()}%"
        query = query.where(
            or_(
                Task.title.ilike(search_term),  # Case-insensitive
                Task.description.ilike(search_term)
            )
        )

    # Apply status filter (FR-026)
    if status == 'pending':
        query = query.where(Task.completed == False)
    elif status == 'completed':
        query = query.where(Task.completed == True)

    # Apply priority filter (FR-027)
    if priority:
        query = query.where(Task.priority == priority)

    # Apply due_date filter (FR-028)
    if due_date:
        operator, date_str = parse_due_date_filter(due_date)
        target_date = datetime.fromisoformat(date_str)

        if operator == 'before':
            query = query.where(Task.due_date < target_date)
        elif operator == 'after':
            query = query.where(Task.due_date > target_date)
        elif operator == 'on':
            query = query.where(func.date(Task.due_date) == target_date.date())

    # Apply sorting (FR-034 to FR-042)
    if sort_by == 'due_date':
        if sort_order == 'desc':
            query = query.order_by(Task.due_date.desc().nullsfirst())
        else:
            query = query.order_by(Task.due_date.asc().nullslast())
    elif sort_by == 'priority':
        priority_order = case(
            (Task.priority == 'high', 1),
            (Task.priority == 'medium', 2),
            (Task.priority == 'low', 3),
        )
        query = query.order_by(
            priority_order.desc() if sort_order == 'desc' else priority_order.asc()
        )
    elif sort_by == 'title':
        query = query.order_by(
            Task.title.desc() if sort_order == 'desc' else Task.title.asc()
        )
    else:
        query = query.order_by(Task.created_at.desc())

    result = await session.execute(query)
    return list(result.scalars().all())
```

**Helper Function**:
```python
def parse_due_date_filter(filter_str: str) -> tuple[str, str]:
    """Parse 'before:YYYY-MM-DD', 'after:YYYY-MM-DD', 'on:YYYY-MM-DD'."""
    if ':' not in filter_str:
        raise HTTPException(
            status_code=400,
            detail="Invalid due_date format. Use 'before:YYYY-MM-DD', 'after:YYYY-MM-DD', or 'on:YYYY-MM-DD'"
        )

    operator, date_str = filter_str.split(':', 1)
    if operator not in ['before', 'after', 'on']:
        raise HTTPException(
            status_code=400,
            detail="Invalid due_date operator. Use 'before', 'after', or 'on'"
        )

    try:
        datetime.fromisoformat(date_str)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid date format. Use YYYY-MM-DD")

    return operator, date_str
```

#### 3.2 Recurring Task Service

**File**: `backend/app/services/recurring_service.py` (NEW)

**Core Logic** (FR-043 to FR-052):
```python
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.task import Task

async def handle_task_completion(
    session: AsyncSession,
    task: Task,
) -> Optional[Task]:
    """
    When a recurring task is marked complete, create a new instance.
    Returns the new task or None if task is not recurring.
    """

    if not task.is_recurring:
        return None

    # Calculate new due date (FR-047, clarification)
    new_due_date = calculate_next_due_date(task.due_date, task.recurrence_pattern)

    # Create new task instance (FR-046, FR-049, FR-050)
    new_task = Task(
        user_id=task.user_id,
        title=task.title,
        description=task.description,
        priority=task.priority,
        completed=False,
        is_recurring=task.is_recurring,
        recurrence_pattern=task.recurrence_pattern,
        due_date=new_due_date,
        reminder_time=calculate_next_reminder(task.reminder_time, task.recurrence_pattern),
    )

    session.add(new_task)
    await session.commit()
    await session.refresh(new_task)

    return new_task


def calculate_next_due_date(
    current_due_date: Optional[datetime],
    pattern: Optional[str],
) -> Optional[datetime]:
    """Calculate next due date based on recurrence pattern."""

    if not current_due_date or not pattern:
        return None  # FR-048

    if pattern == 'daily':
        return current_due_date + timedelta(days=1)
    elif pattern == 'weekly':
        return current_due_date + timedelta(weeks=1)
    elif pattern == 'monthly':
        # Handle month-end edge cases (clarification)
        try:
            return current_due_date + relativedelta(months=1)
        except ValueError:
            next_month = current_due_date + relativedelta(months=1, day=1)
            last_day = next_month + relativedelta(day=31)
            return last_day

    return None


def calculate_next_reminder(
    current_reminder: Optional[datetime],
    pattern: Optional[str],
) -> Optional[datetime]:
    """Shift reminder time same as due date offset."""

    if not current_reminder or not pattern:
        return None

    if pattern == 'daily':
        return current_reminder + timedelta(days=1)
    elif pattern == 'weekly':
        return current_reminder + timedelta(weeks=1)
    elif pattern == 'monthly':
        try:
            return current_reminder + relativedelta(months=1)
        except ValueError:
            next_month = current_reminder + relativedelta(months=1, day=1)
            last_day = next_month + relativedelta(day=31)
            return last_day

    return None
```

**Integration Point**: Call `handle_task_completion()` from `update_task()` service when `completed` transitions from `False` to `True`.

#### 3.3 Validation Enhancements

**File**: `backend/app/services/task_service.py`

**Extend `create_task()` and `update_task()` functions**:
```python
# Validate priority (FR-007)
if data.priority not in ['high', 'medium', 'low']:
    raise HTTPException(status_code=400, detail="Invalid priority")

# Validate reminder_time is in future (FR-056, clarification)
if data.reminder_time:
    if data.reminder_time <= datetime.utcnow():
        raise HTTPException(status_code=400, detail="Reminder time must be in the future")

# Validate due_date format (FR-017)
if data.due_date:
    try:
        datetime.fromisoformat(data.due_date)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid due_date format. Use ISO 8601")
```

---

### Layer 4: Frontend UI Components

#### 4.1 Type Extensions

**File**: `frontend/src/lib/types.ts`

**Extended Task Interface**:
```typescript
export interface Task {
  // ... existing fields ...

  // NEW FIELDS (Phase II Extension)
  priority: 'high' | 'medium' | 'low'
  due_date: string | null
  is_recurring: boolean
  recurrence_pattern: 'daily' | 'weekly' | 'monthly' | null
  reminder_time: string | null
}

export interface TaskFilterParams {
  search?: string
  status?: 'pending' | 'completed'
  priority?: 'high' | 'medium' | 'low'
  due_date?: string
  sort_by?: 'due_date' | 'priority' | 'title'
  sort_order?: 'asc' | 'desc'
}
```

#### 4.2 New UI Components

**Components to Create**:

1. **PrioritySelector.tsx** - Dropdown for priority selection (FR-005)
2. **DateTimePicker.tsx** - Date/time input for due_date and reminder_time (FR-058)
3. **SearchBar.tsx** - Debounced search input (FR-025, 300ms debounce)
4. **FilterControls.tsx** - Status, priority, due_date filters (FR-032)
5. **SortControls.tsx** - Sort dropdown with asc/desc toggle (FR-042)

**Visual Indicators** (FR-005, FR-015, FR-016, SC-020):
- Priority badge: Color-coded (high=red, medium=yellow, low=green)
- Overdue indicator: Red highlight if due_date < now && !completed
- Due today: Yellow/orange highlight
- Recurring icon: Circular arrow if is_recurring=true
- Reminder icon: Bell if reminder_time is set

#### 4.3 Extended Components

**TaskForm.tsx** - Add inputs for:
- PrioritySelector (required)
- DateTimePicker for due_date (optional)
- Recurring checkbox + pattern selector
- DateTimePicker for reminder_time (optional, validate future)

**TaskItem.tsx** - Add visual indicators:
- Priority badge
- Due date with overdue/today styling
- Recurring and reminder icons

**TaskList.tsx** - Add controls:
- SearchBar at top
- FilterControls and SortControls in toolbar

#### 4.4 Browser Notification Service

**File**: `frontend/src/lib/notifications.ts` (NEW)

**Core Functions** (FR-059 to FR-065):
```typescript
export class NotificationService {
  static async requestPermission(): Promise<boolean> {
    if (!('Notification' in window)) return false
    if (Notification.permission === 'granted') return true

    const permission = await Notification.requestPermission()
    return permission === 'granted'
  }

  static scheduleReminder(task: Task): void {
    if (!task.reminder_time || task.completed) return

    const delay = new Date(task.reminder_time).getTime() - Date.now()
    if (delay <= 0) return

    setTimeout(() => this.showNotification(task), delay)
  }

  static showNotification(task: Task): void {
    if (Notification.permission !== 'granted' || task.completed) return

    const notification = new Notification(`Reminder: ${task.title}`, {
      body: task.description || 'You have a task due soon',
      tag: task.id,
    })

    // Navigate to dashboard with task highlighted (clarification)
    notification.onclick = () => {
      window.focus()
      window.location.href = `/dashboard?highlight=${task.id}`
      notification.close()
    }
  }
}
```

**Hook**: `useNotifications.ts` - Request permission, schedule reminders for all tasks

---

### Layer 5: Integration and Testing

#### 5.1 API Client Extensions

**File**: `frontend/src/lib/api.ts`

**Extended getTasks() function**:
```typescript
export async function getTasks(filters?: TaskFilterParams): Promise<Task[]> {
  const params = new URLSearchParams()

  if (filters) {
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        params.append(key, String(value))
      }
    })
  }

  const queryString = params.toString()
  const url = queryString ? `/api/tasks?${queryString}` : '/api/tasks'

  const response = await authenticatedFetch(url)
  return response.json()
}
```

#### 5.2 Dashboard Integration

**File**: `frontend/src/app/dashboard/page.tsx`

**Extensions**:
1. Add SearchBar, FilterControls, SortControls components
2. Manage filter/sort state with `useTaskFilters` hook
3. Pass filters to `getTasks()` API call
4. Initialize notifications with `useNotifications(tasks)`
5. Handle `?highlight={taskId}` query param for notification click-through

#### 5.3 Testing Strategy

**Manual Test Scenarios** (documented in quickstart.md):

1. Priority Management
2. Due Dates (past, today, future, overdue indicators)
3. Search (debouncing, case-insensitive, clear)
4. Filtering (status, priority, due_date, combinations)
5. Sorting (due_date, priority, title, asc/desc, NULL handling)
6. Recurring Tasks (daily, weekly, monthly, edge cases)
7. Reminders (permissions, scheduling, notifications, click-through)
8. Backward Compatibility (existing features unchanged)

---

## Architectural Decision Records (ADR) Suggestions

üìã **Architectural decision detected**: Server-side filtering via query parameters
   Document reasoning and tradeoffs? Run `/sp.adr query-parameter-filtering`

üìã **Architectural decision detected**: Recurring task instance generation model
   Document reasoning and tradeoffs? Run `/sp.adr recurring-task-instances`

üìã **Architectural decision detected**: Client-side browser notifications vs server push
   Document reasoning and tradeoffs? Run `/sp.adr browser-notifications`

---

## Risk Analysis

### Risk 1: Database Migration Failure

**Likelihood**: Medium | **Impact**: High

**Mitigation**:
- Test migration on development database first
- Use database transactions for atomic migration
- Provide rollback script
- Backup production database before migration

### Risk 2: Notification Permission Denial

**Likelihood**: High | **Impact**: Medium

**Mitigation**:
- Graceful degradation (reminders saved, not displayed)
- Clear UI messaging for permission enable
- Alternative reminder methods in Phase III

### Risk 3: Search Performance Degradation

**Likelihood**: Medium | **Impact**: Medium

**Mitigation**:
- Add GIN indexes for full-text search
- Limit search results to 100 tasks
- Implement pagination for large result sets
- Monitor query performance

---

## Definition of Done

Phase II Extension is complete ONLY if ALL conditions are met:

**Database**:
- ‚úÖ Migration adds 5 columns without data loss
- ‚úÖ Existing tasks have priority='medium', is_recurring=false
- ‚úÖ Indexes created on priority, due_date, reminder_time

**Backend**:
- ‚úÖ GET /api/tasks accepts 6 new query parameters
- ‚úÖ POST/PATCH endpoints accept new fields
- ‚úÖ Validation returns HTTP 400 for invalid inputs
- ‚úÖ Recurring task logic creates new instances
- ‚úÖ All 78 functional requirements implemented

**Frontend**:
- ‚úÖ UI components for all new features
- ‚úÖ Search with 300ms debouncing
- ‚úÖ Filter and sort controls
- ‚úÖ Visual indicators (priority, overdue, today)
- ‚úÖ Browser notifications with permission handling

**Integration**:
- ‚úÖ All 7 user stories pass manual testing
- ‚úÖ 20 success criteria validated
- ‚úÖ Backward compatibility maintained
- ‚úÖ No regressions in existing functionality

---

## Next Steps

1. ‚úÖ **Planning Complete**: Design artifacts outlined
2. ‚è≠Ô∏è **Phase 0 - Research**: Generate research.md
3. ‚è≠Ô∏è **Phase 1 - Design**: Generate data-model.md, quickstart.md, contracts/
4. ‚è≠Ô∏è **Run `/sp.tasks`**: Generate implementation task list
5. ‚è≠Ô∏è **Run `/sp.implement`**: Execute tasks to build extensions
6. ‚è≠Ô∏è **Manual Testing**: Follow quickstart.md scenarios
7. ‚è≠Ô∏è **Consider ADRs**: Document 3 architectural decisions

---

**Status**: Ready for Phase 0 research and Phase 1 design
